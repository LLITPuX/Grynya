# Специфікація Проблеми: Конфлікт Event Loop у FastMCP / ClientSession

**Проєкт**: LLM Provider MCP (Grynya-Agent-Box)
**Дата створення**: 2026-02-25
**Пов'язаний план**: [2026-02-25-llm-provider-mcp-phase3-plan.md](../plans/2026-02-25-llm-provider-mcp-phase3-plan.md)
**Пов'язана сесія у FalkorDB**: `session_2026-02-25_15-13-02`

## 1. Суть проблеми

Під час розробки Фази 3 нашого `llm_provider_mcp` (надання серверу можливостей MCP-клієнта), ми зіткнулися з проблемою управління асинхронним циклом обробки подій (Event Loop).

Наш сервер, побудований на `FastMCP`, автоматично обробляє вхідні запити всередині свого власного асинхронного циклу (через `uvicorn`/`starlette`). Інструмент, який буде викликати мовна модель:
```python
@mcp.tool()
async def run_agent_task(prompt: str, ...) -> str:
    ...
```
викликається саме в цьому існуючому циклі.

Якщо всередині цієї функції (яка вже є асинхронною та запущеною у певному loop) ми спробуємо ініціалізувати нове клієнтське підключення (через `mcp.client.sse` або `mcp.client.session.ClientSession`, як було показано в `test_client.py`), ми ризикуємо:
1. Отримати `RuntimeError: This event loop is already running`.
2. Заблокувати основний цикл сервера, поки клієнт очікує відповіді від бази даних.
3. Отримати проблему з некоректним закриттям або витоком ресурсів підключення `streams`.

## 2. Мета наступної сесії (Discovery Interview)

У наступній сесії ми маємо знайти оптимальний спосіб зробити так, щоб:
- У нас було **стабільне, довгоживуче клієнтське підключення** (або пул підключень) до `grynya-mcp-server:8000/sse`.
- Моделі (Gemini/OpenAI) могли синхронно або асинхронно отримувати список доступних інструментів та відправляти `tool_calls`.
- Ми не порушували роботу головного Event Loop сервера `FastMCP`.

## 3. Можливі архітектурні рішення (Для обговорення)

1. **Глобальний клієнт на старті (Lifespan):**
   Використати параметр `lifespan` у `FastMCP(lifespan=...)`, щоб створювати єдину сесію `ClientSession` під час старту сервера та передавати її в інструменти через контекст або глобальну змінну.
2. **Ізоляція в ThreadPoolExecutor:**
   Запускати клієнтські операції в окремому потоці (Thread), використовуючи `asyncio.run_coroutine_threadsafe(..., loop)`.
3. **Lazy Connection (Пули на вимогу):**
   Створювати і кешувати підключення під час першого виклику `run_agent_task`.

## 4. Контекстні файли та вузли

- **Сервер, де очікується проблема**: `@[c:\Antigarvity_workspace\llm_provider_mcp\src\server.py]`
- **Працюючий PoC клієнта (для довідки)**: `@[c:\Antigarvity_workspace\llm_provider_mcp\src\test_client.py]`
- **Вузол сесії в графі**: `session_2026-02-25_15-13-02`
- **Новий план Фази 3**: `@[c:\Antigarvity_workspace\docs\plans\2026-02-25-llm-provider-mcp-phase3-plan.md]`

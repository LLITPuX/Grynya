# Протокол `/db` (Початок нової сесії)

Цей протокол використовується для ініціалізації нової гілки розмови.

**Тригер:** Команда `/db "текст запиту"` від користувача.
**Семантика:** `/db` відкриває нову сесію у графі `Grynya`.

## Твої дії (Взаємодія з MCP)

Щоб відкрити сесію, ти маєш використати нативні інструменти (tools) MCP-сервера для графа `Grynya`.

> [!CAUTION]
> **КРИТИЧНЕ ПРАВИЛО: `/db` = Request + Response + Analysis.**
> Протокол `/db` ЗАВЖДИ створює три вузли одночасно: `:Request`, `:Response` та `:Analysis`.
> Агент НІКОЛИ не може створити сесію без збереження своєї першої відповіді та аналізу.
> Якщо ти не створив Response і Analysis при `/db` — це помилка протоколу.

> [!CAUTION]
> **ОБОВ'ЯЗКОВЕ ЧИТАННЯ КОНТЕКСТУ ОРКЕСТРАЦІЇ**
> Під час обробки запиту `/db` та ініціалізації сесії, ти **ЗОБОВ'ЯЗАНИЙ** спочатку прочитати файл `c:\Antigarvity_workspace\.agent\skills\workflow-orchestration\SKILL.md` (використовуючи інструмент `view_file`). Це гарантує, що ти завантажиш у контекст усі доступні навички і зможеш правильно маршрутизувати подальші дії.

### Крок 0: Верифікація ланцюга сесій (ОБОВ'ЯЗКОВО)
Перед створенням нової сесії:
1. Визнач ID останньої сесії, викликавши інструмент `mcp_falkordb_query_graph` із запитом:
   `MATCH (s:Session) RETURN s.id ORDER BY s.id DESC LIMIT 1`
2. Новий `session_ID` має бути послідовним та відповідати шаблону `session_XXX` (де XXX — тризначне число, наприклад, `session_005` → `session_006`) АБО використовувати таймштамп-формат `session_YYYY-MM-DD_HH-MM-SS_topic`.
3. Вузли всередині сесії повинні використовувати формат `тип_IDсесії_YY` (де YY — порядковий номер події в сесії).
4. Хронологічна лінія в графі має бути ЄДИНОЮ. Це означає, що події (Request, Response, Analysis) пов'язані через `NEXT` в один безперервний ланцюг через всі сесії. Зв'язок `NEXT` між самими вузлами `:Session` НЕ потрібен і є надлишковим.

### Крок 1: Ініціалізація сесії (create_session)
Виклич інструмент `mcp_falkordb_create_session` з потрібними параметрами:
`session_id`, `name`, `topic`, `trigger: '/db'`, `date` (напр., '2026-02-24'), `year` (напр., 2026).
Це автоматично створить вузли Session, Year, Day та налаштує їхні структурні зв'язки.

### Крок 2: Збереження вузлів тріади (Request, Response, Analysis)
Виклич інструмент `mcp_falkordb_add_node` послідовно для кожного з трьох базових вузлів, передавши їх атрибути (у словнику `node_data`, де `id` є обов'язковим), `day_id` (напр., `d_2026_02_24`), поточний `time`, та необхідні базові зв'язки (ЛИШЕ `PART_OF`, `RESPONDS_TO`, `ANALYZES` — тобто ті, де цільовий вузол вже існує і встановлюється вихідне ребро `target_id`).
> **УВАГА:** ЗАБОРОНЕНО передавати зв'язки `NEXT` через параметр `relations` інструменту `add_node`, оскільки він не підтримує `source_id` для вхідних ребер! Всі `NEXT` створюються окремим кроком 2.1.

**1. Request:**
- Атрибути: `id`, `text` (запит користувача).
- Зв'язки (у параметрі `relations`): `PART_OF` (target: поточна Session).

**2. Response:** 
- Атрибути: `id`, `name`, `author: 'Grynya'`, `summary`, `full_text` (ПОВНИЙ текст СЛОВО В СЛОВО), `type: 'text'`.
- Зв'язки (у параметрі `relations`): `PART_OF` (target: Session), `RESPONDS_TO` (target: Request).

**3. Analysis:**
- Атрибути: `id`, `name`, `type: 'response_analysis'`, `verdict`, `rules_used`, `errors`, `lessons`.
- Зв'язки (у параметрі `relations`): `PART_OF` (target: Session), `ANALYZES` (target: Response).

### Крок 2.1: Створення хронологічних ланцюжків `[:NEXT]`
ОБОВ'ЯЗКОВО виклич інструмент `mcp_falkordb_batch_link_nodes` (або `mcp_falkordb_link_nodes` для кожного зв'язку) та передай масив зв'язків `NEXT`, явно вказуючи `source_id` та `target_id`:
1. Від останньої події (Analysis) ПОПЕРЕДНЬОЇ сесії до першої події (Request) поточної сесії.
2. Від поточної сесії `Session` до щойно створеного `Request`.
3. Від `Request` до `Response`.
4. Від `Response` до `Analysis`.

### Крок 3: Витяг та пакетне збереження сутностей (batch tools)
1. Проаналізуй запит користувача ТА свою відповідь. Витягни УСІ значущі концепції (Entities).
2. Виклич інструмент `mcp_falkordb_batch_add_nodes`, передавши `node_type: "Entity"` та масив цих сутностей у параметр `nodes` (для `:Entity` day_id та time передавати не потрібно).
3. Виклич інструмент `mcp_falkordb_batch_link_nodes` передавши масив всіх зв'язків для сутностей: `INVOLVES` (source: поточна Session, target: Entity) та `MENTIONS` (source: Request/Response/Analysis, target: Entity).

### Крок 4: Оновлення LAST_EVENT
Виклич інструмент `mcp_falkordb_update_last_event`, щоб оновити вказівник `LAST_EVENT` сесії на ID вузла Analysis.

**Виконання:** Поверни користувачу підтвердження "✅ Сесію ініціалізовано. Артефакти збережено [ID вузлів]".
